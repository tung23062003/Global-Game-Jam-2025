// <autogenerated /> because this is copy of Selectable editor
#if UNITY_EDITOR
namespace UIWidgets
{
	using UnityEditor;
	using UnityEditor.AnimatedValues;
	using UnityEditor.Animations;
	using UnityEngine;
	using UnityEngine.Events;
	using UnityEngine.UI;

	/// <summary>
	/// SelectableHelper editor.
	/// </summary>
	[CustomEditor(typeof(SelectableHelper), true)]
	public class SelectableHelperEditor : UIWidgetsMonoEditor
	{
		SerializedProperty script;
		SerializedProperty targetGraphic;
		SerializedProperty transition;
		SerializedProperty colorBlock;
		SerializedProperty spriteState;
		SerializedProperty animTrigger;

		SerializedProperty interactable;
		SerializedProperty watchInteractable;

		AnimBool showColorTint = new AnimBool();
		AnimBool showSpriteTrasition = new AnimBool();
		AnimBool showAnimTransition = new AnimBool();

		string[] propertyPathToExcludeForChildClasses;

		UnityAction repaintDelegate;

		UnityAction RepaintDelegate
		{
			get
			{
				if (repaintDelegate == null)
				{
					repaintDelegate = Repaint;
				}

				return repaintDelegate;
			}
		}

		/// <summary>
		/// Init.
		/// </summary>
		protected virtual void OnEnable()
		{
			script = serializedObject.FindProperty("m_Script");
			targetGraphic = serializedObject.FindProperty("targetGraphic");
			transition = serializedObject.FindProperty("transition");
			colorBlock = serializedObject.FindProperty("colors");
			spriteState = serializedObject.FindProperty("spriteState");
			animTrigger = serializedObject.FindProperty("animationTriggers");

			interactable = serializedObject.FindProperty("interactable");
			watchInteractable = serializedObject.FindProperty("watchInteractable");

			propertyPathToExcludeForChildClasses = new[] {
				script.propertyPath,
				transition.propertyPath,
				colorBlock.propertyPath,
				spriteState.propertyPath,
				animTrigger.propertyPath,
				targetGraphic.propertyPath,

				interactable.propertyPath,
				watchInteractable.propertyPath,
			};

			var trans = GetTransition(transition);
			showColorTint.value = (trans == Selectable.Transition.ColorTint);
			showSpriteTrasition.value = (trans == Selectable.Transition.SpriteSwap);
			showAnimTransition.value = (trans == Selectable.Transition.Animation);

			showColorTint.valueChanged.AddListener(RepaintDelegate);
			showSpriteTrasition.valueChanged.AddListener(RepaintDelegate);
		}

		/// <summary>
		/// Disable.
		/// </summary>
		protected virtual void OnDisable()
		{
			showColorTint.valueChanged.RemoveListener(RepaintDelegate);
			showSpriteTrasition.valueChanged.RemoveListener(RepaintDelegate);
		}

		static Selectable.Transition GetTransition(SerializedProperty transition)
		{
			return (Selectable.Transition)transition.enumValueIndex;
		}

		/// <summary>
		/// Draw inspector GUI.
		/// </summary>
		public override void OnInspectorGUI()
		{
			ValidateTargets();

			serializedObject.Update();

			if (!IsDerivedSelectableHelperEditor())
			{
				EditorGUILayout.PropertyField(script);
			}

			var sh = target as SelectableHelper;

			var trans = GetTransition(transition);

			var graphic = targetGraphic.objectReferenceValue as Graphic;
			if (graphic == null)
			{
				sh.TryGetComponent<Graphic>(out graphic);
			}

			sh.TryGetComponent<Animator>(out var animator);
			showColorTint.target = (!transition.hasMultipleDifferentValues && trans == Button.Transition.ColorTint);
			showSpriteTrasition.target = (!transition.hasMultipleDifferentValues && trans == Button.Transition.SpriteSwap);
			showAnimTransition.target = (!transition.hasMultipleDifferentValues && trans == Button.Transition.Animation);

			EditorGUILayout.PropertyField(interactable);
			EditorGUILayout.PropertyField(watchInteractable);

			EditorGUILayout.PropertyField(transition);

			++EditorGUI.indentLevel;
			{
				if (trans == Selectable.Transition.ColorTint || trans == Selectable.Transition.SpriteSwap)
				{
					EditorGUILayout.PropertyField(targetGraphic);
				}

				switch (trans)
				{
					case Selectable.Transition.ColorTint:
						if (graphic == null)
						{
							EditorGUILayout.HelpBox("You must have a Graphic target in order to use a color transition.", MessageType.Warning);
						}
						break;

					case Selectable.Transition.SpriteSwap:
						if (graphic as Image == null)
						{
							EditorGUILayout.HelpBox("You must have a Image target in order to use a sprite swap transition.", MessageType.Warning);
						}
						break;
				}

				if (EditorGUILayout.BeginFadeGroup(showColorTint.faded))
				{
					EditorGUILayout.PropertyField(colorBlock);
					EditorGUILayout.Space();
				}
				EditorGUILayout.EndFadeGroup();

				if (EditorGUILayout.BeginFadeGroup(showSpriteTrasition.faded))
				{
					EditorGUILayout.PropertyField(spriteState);
					EditorGUILayout.Space();
				}
				EditorGUILayout.EndFadeGroup();

				if (EditorGUILayout.BeginFadeGroup(showAnimTransition.faded))
				{
					EditorGUILayout.PropertyField(animTrigger);

					if (animator == null || animator.runtimeAnimatorController == null)
					{
						Rect buttonRect = EditorGUILayout.GetControlRect();
						buttonRect.xMin += EditorGUIUtility.labelWidth;
						if (GUI.Button(buttonRect, "Auto Generate Animation", EditorStyles.miniButton))
						{
							var controller = GenerateSelectableAnimatorContoller(sh.AnimationTriggers, sh);
							if (controller != null)
							{
								if (animator == null)
								{
									animator = sh.gameObject.AddComponent<Animator>();
								}

								AnimatorController.SetAnimatorController(animator, controller);
							}
						}
					}
				}
				EditorGUILayout.EndFadeGroup();
			}
			--EditorGUI.indentLevel;

			EditorGUILayout.Space();

			EditorGUI.BeginChangeCheck();
			Rect toggleRect = EditorGUILayout.GetControlRect();
			toggleRect.xMin += EditorGUIUtility.labelWidth;

			ChildClassPropertiesGUI();

			UtilitiesEditor.ApplyModifiedProperties(serializedObject);

			ValidateTargets();
		}

		void ChildClassPropertiesGUI()
		{
			if (IsDerivedSelectableHelperEditor())
			{
				return;
			}

			DrawPropertiesExcluding(serializedObject, propertyPathToExcludeForChildClasses);
		}

		bool IsDerivedSelectableHelperEditor()
		{
			return GetType() != typeof(SelectableHelperEditor);
		}

		static AnimatorController GenerateSelectableAnimatorContoller(AnimationTriggers animationTriggers, SelectableHelper target)
		{
			if (target == null)
			{
				return null;
			}

			var path = GetSaveControllerPath(target);
			if (string.IsNullOrEmpty(path))
			{
				return null;
			}

			var normalName = string.IsNullOrEmpty(animationTriggers.normalTrigger) ? "Normal" : animationTriggers.normalTrigger;
			var highlightedName = string.IsNullOrEmpty(animationTriggers.highlightedTrigger) ? "Highlighted" : animationTriggers.highlightedTrigger;
			var pressedName = string.IsNullOrEmpty(animationTriggers.pressedTrigger) ? "Pressed" : animationTriggers.pressedTrigger;
			var disabledName = string.IsNullOrEmpty(animationTriggers.disabledTrigger) ? "Disabled" : animationTriggers.disabledTrigger;

			var controller = AnimatorController.CreateAnimatorControllerAtPath(path);

			GenerateTriggerableTransition(normalName, controller);
			GenerateTriggerableTransition(highlightedName, controller);
			GenerateTriggerableTransition(pressedName, controller);
			GenerateTriggerableTransition(disabledName, controller);

			return controller;
		}

		static string GetSaveControllerPath(SelectableHelper target)
		{
			var defaultName = target.gameObject.name;
			var message = string.Format("Create a new animator for the game object '{0}':", defaultName);

			return EditorUtility.SaveFilePanelInProject("New Animation Controller", defaultName, "controller", message);
		}

		static AnimationClip GenerateTriggerableTransition(string name, AnimatorController controller)
		{
			var clip = AnimatorController.AllocateAnimatorClip(name);
			AssetDatabase.AddObjectToAsset(clip, controller);

			var state = controller.AddMotion(clip);

			controller.AddParameter(name, UnityEngine.AnimatorControllerParameterType.Trigger);

			var stateMachine = controller.layers[0].stateMachine;
			var transition = stateMachine.AddAnyStateTransition(state);
			transition.AddCondition(UnityEditor.Animations.AnimatorConditionMode.If, 0, name);

			return clip;
		}
	}
}
#endif